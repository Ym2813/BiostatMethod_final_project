---
title: "draft_yma"
author: "Anna Ma"
date: "12/12/2021"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
```

## Data exploration

 **converted variables to per person and docs, beds, etc.** 


```{r, message=FALSE}
cdi = read_csv("cdi.csv") %>%
  janitor::clean_names() %>%
  mutate(crm_1000 = 1000*(crimes/pop),
         pdocs_1000 = 1000*(docs/pop),
         pbeds_1000 = 1000*(beds/pop),
         density_pop = pop/area,
         # convert region to factors and recoded them accordingly 
         region = factor(region, levels = 1:4,
                    labels = c("northeast", "north central", "south", "west"))) %>% select(-c(docs,beds)) %>% view()
  
```

### Descriptive statistics of all varaibles
```{r statistic summary}

cdi_descriptive = cdi %>% select(-c(id,cty,state,region))

# Global
skimr::skim(cdi_descriptive) %>% 
  select(-c("skim_type","complete_rate")) %>% 
    mutate(skim_variable = 
             recode(skim_variable, pcincome = "pcincome (in dollars)", totalinc = "totalinc (in million of dollars)"
  )) %>% 
  knitr::kable(
    col.names = c("variable", "n_missing", "mean","sd","min","Q25","median","Q75","max","histogram"),
    caption = "Global Summary", digits = 4)

ggplot(gather(cdi_descriptive), aes(value)) + 
    geom_histogram(bins = 13) + 
    facet_wrap(~key, scales = 'free_x')
```

Q: 1. do we need to group them by state or county? group by gounty gives 5000+ rows though...
  2. do we need box plot still? 
  3. again, transfer some variables to "per pop" / "per 1000 pop" ?


### Descriptive analysis

We can use the box plot/ or histogram to check for normality. But I forgot when do we need normality...isn't it for residual??

```{r}
par(mfrow = c(3,5))

boxplot(cdi$density_pop,  main = "density_pop")
boxplot(cdi$area, main = "area")

boxplot(cdi$pop, main = "pop")
boxplot(cdi$pop18, main = "pop18")
boxplot(cdi$pop65, main = "pop65")

boxplot(cdi$pdocs_1000, main = "pdocs_1000")
boxplot(cdi$pbeds_1000, main = "pbeds_1000")

boxplot(cdi$crm_1000,  main = "crm_1000")

boxplot(cdi$hsgrad, main = "hsgrad")
boxplot(cdi$bagrad, main = "bagrad")
boxplot(cdi$poverty, main = "poverty")
boxplot(cdi$unemp,main = "unemp")
boxplot(cdi$pcincome, main = "pcincome")
boxplot(cdi$totalinc, main = "totalinc")

```


### Correlation 

#### Pairwise relationship 

* This gives us an idea of the correlation between each variable, but my old project build whole model first then assessed the correlation. Need Discussion!

```{r}
library(corrplot)
cor(cdi_descriptive) %>% knitr::kable()

library(ggcorrplot)
library(ggstatsplot)
ggstatsplot::ggcorrmat(
  data = cdi_descriptive,
  type = "parametric", # parametric for Pearson, nonparametric for Spearman's correlation
  colors = c("darkred", "white", "steelblue") # change default colors
)
```


* Here is the correlation with pairs function. More specific than the heat map above. We can observe the correlation between all the terms here
```{r}
pairs(crm_1000 ~.,data=cdi_descriptive, panel = panel.smooth, upper.panel = NULL, main = "Scatterplot Matrix")
```

#### Marginal distribution ?

```{r}
library(ggplot2)
library(ggExtra)

```

```{r}
marg_den = cdi %>% ggplot(aes(x = density_pop, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_den, type = "histogram", fill="transparent")
```

```{r}
marg_area = cdi %>% ggplot(aes(x = area, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_area, type = "histogram", fill="transparent")
```

```{r}
marg_pop = cdi %>% ggplot(aes(x = pop, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_pop, type = "histogram", fill="transparent")
```

```{r}
marg_pop18 = cdi %>% ggplot(aes(x = pop18, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
# positive correlation
ggMarginal(marg_pop18, type = "histogram", fill="transparent")
```

```{r}
marg_pop65 = cdi %>% ggplot(aes(x = pop65, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_pop65, type = "histogram", fill="transparent")
```

```{r}
marg_pdocs_1000 = cdi %>% ggplot(aes(x = pdocs_1000, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_pdocs_1000, type = "histogram", fill="transparent")
```

```{r}
marg_pbeds_1000 = cdi %>% ggplot(aes(x = pbeds_1000, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_pbeds_1000, type = "histogram", fill="transparent")
```

```{r}
marg_hsgrad = cdi %>% ggplot(aes(x = hsgrad, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red') #negative correlation
ggMarginal(marg_hsgrad, type = "histogram", fill="transparent")
```

```{r}
marg_bagrad = cdi %>% ggplot(aes(x = bagrad, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_bagrad, type = "histogram", fill="transparent")
```

```{r}
marg_poverty = cdi %>% ggplot(aes(x = poverty, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red') # positive correlation
ggMarginal(marg_poverty, type = "histogram", fill="transparent")
```

```{r}
marg_unemp = cdi %>% ggplot(aes(x = unemp, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_unemp, type = "histogram", fill="transparent")
```

```{r}
marg_pcincome = cdi %>% ggplot(aes(x = pcincome, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_pcincome, type = "histogram", fill="transparent")
```

```{r}
marg_totalinc = cdi %>% ggplot(aes(x = totalinc, y = crm_1000)) + geom_point(alpha = 0.3) + geom_smooth(method = 'lm', se = TRUE, color = 'red')
ggMarginal(marg_totalinc, type = "histogram", fill="transparent")
```



### Distribution of outcome

```{r}
cdi %>% 
  ggplot(aes(x = crm_1000)) +
  geom_histogram()

# log transfor the outcome
cdi %>% 
  ggplot(aes(x = log(crm_1000))) +
  geom_histogram()


```

do we look at the distribution of outcome like this and transform them here? check again

### States with unusual rates

group by state
```{r}
cdi_by_state = cdi %>% group_by(state) %>% 
  summarise(state_pop = sum(pop),
            state_crimes = sum(crimes)) %>% 
  mutate(state_CRM_1000 = 1000*state_crimes/state_pop)
```

Not sure what counts as out lier, this is what the other group did. 

```{r}
upper = quantile(cdi$crm_1000, 0.75)
lower = quantile(cdi$crm_1000, 0.25)
IQR = upper - lower
cdi %>% 
  filter(crm_1000 > upper + 1.5*IQR,
         crm_1000 > lower - 1.5*IQR) %>% 
  dplyr::select(cty, crm_1000) %>%
  knitr::kable(digits = 2)
```


This shows no outlier on the state level tho... 

```{r}
upper = quantile(cdi_by_state$state_CRM_1000, 0.75)
lower = quantile(cdi_by_state$state_CRM_1000, 0.25)
IQR = upper - lower
cdi_by_state %>% 
  filter(state_CRM_1000 > upper + 1.5*IQR,
         state_CRM_1000 > lower - 1.5*IQR) %>% 
  dplyr::select(state, state_CRM_1000) %>%
  knitr::kable(digits = 2)
boxplot(cdi_by_state$state_CRM_1000, main = 'State Crime Rate per 1000 people')
```

**we probably need to plot region as well? not sure**

## Model! 

**Q: do we need more descriptive analysis, visualization? rate of crime for each state?**
**there's a few duplicated cty, but different area, maybe diff place then? not sure**
they can't be the same... otherwise we have to recalculate some stuff...
duplicated(cdi[,2:3])
cdi %>% filter(cty == "Baltimor")
cdi %>% filter(cty == "St._Loui")


#### Full model predictors ok?

this model used `northeast` as the reference level for region 

```{r}
cdi_model = cdi %>% select(-c(id,cty,state,area,crimes,totalinc))

# use 
full_fit = lm(crm_1000 ~ ., data = cdi_model)
summary(full_fit)

olsrr::ols_plot_resid_qq(full_fit)
olsrr::ols_plot_resid_fit(full_fit)
```


## Transformation
```{r}
lambda = MASS::boxcox(full_fit)
optlam = lambda$x[which.max(lambda$y)]
optlam
```

The lambda from the transformation is 0.5454, so we will try to fit a square root transformation to y

```{r}
trans_fit = lm(crm_1000^0.5 ~ .,data = cdi_model)
summary(trans_fit)

olsrr::ols_plot_resid_fit(trans_fit)
olsrr::ols_plot_resid_qq(trans_fit)

lambda_trans = MASS::boxcox(trans_fit)
optlam_trans = lambda_trans$x[which.max(lambda_trans$y)]
lambda_trans
```


#### Backward

```{r}
fit_back = step(trans_fit, direction='backward')
fit_back
```


#### forward 

```{r}
fit_forward = step(trans_fit, direction='forward')
fit_forward
```

    
#### both

step-wise?

```{r}
fit_both = step(trans_fit, direction='both')
fit_both
```

crm_1000 ~ pop + pop18 + hsgrad + bagrad + poverty + 
    pcincome + region + pbeds_1000 + density_pop, data = cdi_model
This gives back the same model as back 
    
Some group forward again based on their first time step wise...not sure if we need to do that tho

### Test based procedures 

#### Cp

I didn't include the full model here

**backward & both**

```{r}
# printing the 2 best models of each size. For example, the first two lines: print the best 2 models that have 2 variables (including intercept)
library(leaps)
Cp_b = leaps(x = model.matrix(fit_back)[,-1],
      y = cdi_model$crm_1000,
      nbest = 2,
      method = "Cp")
Cp_b

Cp_b %>% faraway::Cpplot()
```

size is the number of parameters in the model, Cp is Cp

The plot shows the model that satisfy the criteria, number indicates the number of parameters it included. in this case, the 1st to the last.


**forward**
```{r}
leaps(x = model.matrix(fit_forward)[,-1],
      y = cdi_model$crm_1000,
      nbest = 2,
      method = "Cp") %>% faraway::Cpplot()
```

So, multiple model satisfies the Cp criteria here. 

#### Adj R2

**backward**
```{r}
adjr_b = leaps(x = model.matrix(fit_back)[,-1],
      y = cdi_model$crm_1000,
      nbest = 2,
      method = "adjr2") 

adjr_b

adjr_b%>% 
  faraway::maxadjr(10)
```


**forward**
```{r}
leaps(x = model.matrix(fit_forward)[,-1],
      y = cdi_model$crm_1000,
      nbest = 2,
      method = "adjr2") %>% faraway::maxadjr(10)
```

## backward by hand

```{r}
# No docs
step1 = update(full_fit, . ~ . -pdocs_1000)
summary(step1)

# No pop65
step2 = update(step1, . ~ . -pop65)
summary(step2)

# No unemp
step3 = update(step2, . ~ . -unemp)
summary(step3)

mult.fit.final = lm(formula = crm_1000 ~ pop + pop18 + hsgrad + bagrad + poverty + 
    pcincome + region + pbeds_1000 + density_pop, data = cdi_model)
summary(mult.fit.final)
```